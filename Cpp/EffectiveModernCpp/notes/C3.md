# Chapter 3. Moving to Modern C++

[TOC]

## Item 7: 创建对象时区分 `()` 和 `{}` Distinguish between `()` and `{}` when creating objects 

### 1. 初始化方式

```c++
int x(0); // initializer is in parentheses
int y = 0; // initializer follows "="
int z{ 0 }; // initializer is in braces
```

初始化时使用 `=` 会调用构造函数（普通构造函数或者拷贝构造函数）

非初始化时使用 `=` 会调用赋值函数（`operator =`）

### 2. uniform initialization / braced initialization

```c++
class Widget {
	///…
private:
    int x{ 0 }; // fine, x's default value is 0
    int y = 0; // also fine
    int z(0); // error!
};
```

```c++
std::atomic<int> ai1{ 0 }; // fine
std::atomic<int> ai2(0); // fine
std::atomic<int> ai3 = 0; // error!
```

### 3. 禁止内置类型的隐式  **narrowing conversions** 

```c++
double x, y, z;
int sum1{ x + y + z }; // error! sum of doubles may
                       // not be expressible as int
int sum2(x + y + z); // okay (value of expression
                     // truncated to an int)
int sum3 = x + y + z; // ditto
```

### 4. 默认构造函数变成了声明函数

```c++
Widget w2(); // most vexing parse! declares a function
             // named w2 that returns a Widget!
Widget w3{}; // calls Widget ctor with no args
```

### 5. braced initializers, `std::initializer_lists` 和构造函数重载决策会产生问题

```c++
class Widget {
public:
    Widget(int i, bool b); // as before
    Widget(int i, double d); // as before
    Widget(std::initializer_list<long double> il); // added
};

Widget w1(10, true); // uses parens and, as before,
                     // calls first ctor
Widget w2{10, true}; // uses braces, but now calls
                     // std::initializer_list ctor
                     // (10 and true convert to long double)
Widget w3(10, 5.0); // uses parens and, as before,
                    // calls second ctor
Widget w4{10, 5.0}; // uses braces, but now calls
                    // std::initializer_list ctor
                    // (10 and 5.0 convert to long double)
```

对 `std::vector` 会造成很大影响

> 过于恶心，所以一般开发就不要考虑使用 `std::initializer_lists` 了

