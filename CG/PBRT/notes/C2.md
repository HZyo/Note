# C02. 几何变换 Geometry and Transformations

[TOC]

## 2.1 坐标系 Coordinate Systems

坐标系定义了空间的原点和三个线性无关的向量（定义了 x，y 和 z 轴）。原点和三个向量称作 frame，定义了坐标系。

标准 frame：原点 (0, 0, 0)​，基向量为 (1, 0, 0)，(0, 1, 0) 和 (0, 0, 1)。称为 world space。

### 2.1.1 坐标系手性 Coordinate System Handedness

有两种坐标系

![1553743777559](assets/1553743777559.png)

`pbrt` 用左手系（a）

## 2.2 向量 Vectors

...

## 2.3 点 Points

...

## 2.4 法向 Normals

...

## 2.5 射线 Rays

包含 `Medium` 和 `time` 

`RayDifferential` 是 `Ray` 的子类，包含了两个辅助射线（成像平面上在 x 和 y 方向上偏移了一个样本）的信息，用于纹理反走样。

## 2.6 包围盒 Bounding Boxes

![1553745267640](assets/1553745267640.png)

## 2.7 变换 Transformations

...

### 2.7.5 x, y, z 轴旋转 x, y, z Axis Rotations

$$
\begin{aligned} \mathrm{R}_{a}(0) &=\mathrm{I} \\ \mathrm{R}_{a}\left(\theta_{1}\right) \mathrm{R}_{a}\left(\theta_{2}\right) &=\mathrm{R}_{a}\left(\theta_{1}+\theta_{2}\right) \\ \mathrm{R}_{a}\left(\theta_{1}\right) \mathrm{R}_{a}\left(\theta_{2}\right) &=\mathrm{R}_{a}\left(\theta_{2}\right) \mathrm{R}_{a}\left(\theta_{1}\right) \\ \mathrm{R}_{a}^{-1}(\theta) &=\mathrm{R}_{a}(-\theta)=\mathrm{R}_{a}^{T}(\theta) \end{aligned}
$$

旋转矩阵的列向量对应着旋转矩阵对应的坐标系在世界坐标下的三个轴。所以其作用于 (1, 0, 0)，(0, 1, 0) 和 (0, 0, 1) 就可以得到世界坐标下的三个轴了。

我们只需要计算出 (1, 0, 0)，(0, 1, 0) 和 (0, 0, 1) 旋转后的向量，就可以计算得到旋转矩阵。

### 2.7.6 绕任意轴旋转 Rotation around an arbitratry axis

我们需要计算出 (1, 0, 0)，(0, 1, 0) 和 (0, 0, 1) 旋转后的向量。

假设需要旋转的向量为 v，轴为 a。示意图如下

![1553750303772](assets/1553750303772.png)

我们可以计算出 $v'$。
$$
\mathbf{v}_{\mathbf{c}}=\mathbf{a}\|\mathbf{v}\| \cos \alpha=\mathbf{a}(\mathbf{v} \cdot \mathbf{a})\\
\mathbf{v}_{1}=\mathbf{v}-\mathbf{v}_{\mathbf{c}}\\
\mathbf{v}_{2}=\left(\mathbf{v}_{1} \times \mathbf{a}\right)\\
\mathbf{v}^{\prime}=\mathbf{v}_{\mathbf{c}}+\cos \theta\mathbf{v}_{1} +\sin \theta\mathbf{v}_{2} 

$$
我们将 (1, 0, 0)，(0, 1, 0) 和 (0, 0, 1) 代入以上的 v 即可求得三个 $v'$，从而得到旋转矩阵。

> 注意手系问题。上边的示意图用的是右手系，而 `pbrt` 是左手系。

计算结果为

右手系
$$
\mathbf{R}_{a}(\theta)=\left[ \begin{array}{cccc}{a_{x}^{2}+\left(1-a_{x}^{2}\right) \cos \theta} & {a_{x} a_{y}(1-\cos \theta)+a_{z} \sin \theta} & {a_{x} a_{z}(1-\cos \theta)-a_{y} \sin \theta} & {0} \\ {a_{x} a_{y}(1-\cos \theta)-a_{z} \sin \theta} & {a_{y}^{2}+\left(1-a_{y}^{2}\right) \cos \theta} & {a_{y} a_{z}(1-\cos \theta)+a_{x} \sin \theta} & {0} \\ {a_{x} a_{z}(1-\cos \theta)+a_{y} \sin \theta} & {a_{y} a_{z}(1-\cos \theta)-a_{x} \sin \theta} & {a_{z}^{2}+\left(1-a_{z}^{2}\right) \cos \theta} & {0} \\ {0} & {0} & {0} & {1}\end{array}\right]
$$
左手系
$$
\mathbf{R}_{a}(\theta)=\left[ \begin{array}{cccc}{a_{x}^{2}+\left(1-a_{x}^{2}\right) \cos \theta} & {a_{x} a_{y}(1-\cos \theta)-a_{z} \sin \theta} & {a_{x} a_{z}(1-\cos \theta)+a_{y} \sin \theta} & {0} \\ {a_{x} a_{y}(1-\cos \theta)+a_{z} \sin \theta} & {a_{y}^{2}+\left(1-a_{y}^{2}\right) \cos \theta} & {a_{y} a_{z}(1-\cos \theta)-a_{x} \sin \theta} & {0} \\ {a_{x} a_{z}(1-\cos \theta)-a_{y} \sin \theta} & {a_{y} s i n \theta} & {a_{y} a_{z}(1-c o s \theta)+a_{x} \sin \theta} & {a_{z}^{2}+\left(1-a_{z}^{2}\right) \cos \theta} & {0} \\ {0} & {0} & {0} & {1}\end{array}\right]
$$

### 2.7.7 Look-at 变换 The Look-at Transformation

![1553754598785](assets/1553754598785.png)

```c++
Transform LookAt(const Point3f &pos, const Point3f &look, const Vector3f &up) {
    Matrix4x4 cameraToWorld;
    Vector3f dir = Normalize(look - pos);
    Vector3f left = Normalize(Cross(Normalize(up), dir));
    Vector3f newUp = Cross(dir, left);
    cameraToWorld.m[0][3] = pos.x;
    cameraToWorld.m[1][3] = pos.y;
    cameraToWorld.m[2][3] = pos.z;
    cameraToWorld.m[3][3] = 1;
    cameraToWorld.m[0][0] = left.x;
    cameraToWorld.m[1][0] = left.y;
    cameraToWorld.m[2][0] = left.z;
    cameraToWorld.m[3][0] = 0.;
    cameraToWorld.m[0][1] = newUp.x;
    cameraToWorld.m[1][1] = newUp.y;
    cameraToWorld.m[2][1] = newUp.z;
    cameraToWorld.m[3][1] = 0.;
    cameraToWorld.m[0][2] = dir.x;
    cameraToWorld.m[1][2] = dir.y;
    cameraToWorld.m[2][2] = dir.z;
    cameraToWorld.m[3][2] = 0.;
	return Transform(Inverse(cameraToWorld), cameraToWorld);
}
```

## 2.8 使用变换 Applying Transformations

### 2.8.1 点 Points

```c++
template <typename T> inline Point3<T>
Transform::operator()(const Point3<T> &p) const {
    T x = p.x, y = p.y, z = p.z;
    T xp = m.m[0][0]*x + m.m[0][1]*y + m.m[0][2]*z + m.m[0][3];
    T yp = m.m[1][0]*x + m.m[1][1]*y + m.m[1][2]*z + m.m[1][3];
    T zp = m.m[2][0]*x + m.m[2][1]*y + m.m[2][2]*z + m.m[2][3];
    T wp = m.m[3][0]*x + m.m[3][1]*y + m.m[3][2]*z + m.m[3][3];
    if (wp == 1) return Point3<T>(xp, yp, zp); // 除法优化
    else return Point3<T>(xp, yp, zp) / wp;
}
```

### 2.8.2 向量 Vectors

```c++
template <typename T> inline Vector3<T>
Transform::operator()(const Vector3<T> &v) const {
    T x = v.x, y = v.y, z = v.z;
    return Vector3<T>(m.m[0][0]*x + m.m[0][1]*y + m.m[0][2]*z,
    m.m[1][0]*x + m.m[1][1]*y + m.m[1][2]*z,
    m.m[2][0]*x + m.m[2][1]*y + m.m[2][2]*z);
}
```

### 2.8.3 法向 Normals

法向的变换比较特殊，要求变换后依然垂直于表面

![1553755265590](assets/1553755265590.png)
$$
\mathbf{n} \cdot \mathbf{t}=\mathbf{n}^{T} \mathbf{t}=0\\
\begin{aligned} 0 &=\left(\mathbf{n}^{\prime}\right)^{T} \mathbf{t}^{\prime} \\ &=(\mathbf{S} n)^{T} \mathbf{M t} \\ &=\mathbf{n}^{T} \mathbf{S}^{T} \mathbf{M t} \end{aligned}\\
\mathbf{S}=(\mathbf{M}^{-1})^T
$$

```c++
template <typename T> inline Normal3<T>
Transform::operator()(const Normal3<T> &n) const {
    T x = n.x, y = n.y, z = n.z;
    return Normal3<T>(mInv.m[0][0]*x + mInv.m[1][0]*y + mInv.m[2][0]*z,
    mInv.m[0][1]*x + mInv.m[1][1]*y + mInv.m[2][1]*z,
    mInv.m[0][2]*x + mInv.m[1][2]*y + mInv.m[2][2]*z);
}
```

### 2.8.4  射线 Rays

变换 o 和 d 即可

### 2.8.5 包围盒 Bounding Boxes

对8个顶点进行变换，然后计算这八个顶点的包围盒即可

> 可以优化

### 2.8.6 变换组合 Composition of Transformations

$$
A(B(C(p)))=T(p)\\
T=ABC\\
T^{-1}=C^{-1}B^{-1}A^{-1}
$$

```c++
Transform Transform::operator*(const Transform &t2) const {
    return Transform(Matrix4x4::Mul(m, t2.m), Matrix4x4::Mul(t2.mInv, mInv));
}
```

### 2.8.7  变换和坐标系手性

```c++
bool Transform::SwapsHandedness() const {
    Float det =
    m.m[0][0] * (m.m[1][1] * m.m[2][2] - m.m[1][2] * m.m[2][1]) -
    m.m[0][1] * (m.m[1][0] * m.m[2][2] - m.m[1][2] * m.m[2][0]) +
    m.m[0][2] * (m.m[1][0] * m.m[2][1] - m.m[1][1] * m.m[2][0]);
    return det < 0;
}
```

## *2.9 动画变化 Animating Transformations

...

## 2.10 交互 Interactions

...